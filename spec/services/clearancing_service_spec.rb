require 'rails_helper'

describe ClearancingService do
  subject(:clearancing_service) { ClearancingService.new }

  describe "::clearance_batch" do

    context "total success" do
      let!(:items) { 5.times.map { FactoryGirl.create(:item) } }
      let(:batch) { items.map(&:id) }

      before do
        @clearancing_status = clearancing_service.clearance_batch(batch)
      end

      it "creates a clearance batch" do
        expect(@clearancing_status.clearance_batch.new_record?).to be false
      end

      it "encounters no errors" do

        expect(@clearancing_status.errors.empty?).to be true
      end

      it "adds all the items to the batch" do
        expect(@clearancing_status.clearance_batch.items.pluck(:id).sort).to eq(items.map(&:id).sort)
      end

      it "sets all items to 'clearanced' status" do
        expect(@clearancing_status.clearance_batch.items.pluck(:status).uniq).to eq(["clearanced"])
      end
    end

    context "partial success" do
      let(:valid_items)       { 3.times.map { FactoryGirl.create(:item) } }
      let(:unsellable_item)   { FactoryGirl.create(:item, status: 'clearanced') }
      let(:underpriced_style)  { FactoryGirl.create(:style, wholesale_price: BigDecimal.new("6.00")) }
      let(:underpriced_item)   { FactoryGirl.create(:item, style: underpriced_style) }
      let(:invalid_item_ids) { ["cat", 0, 3.3] }
      let(:unfindable_item_id) { 35342 }
      let(:unclearancable_item_ids) { Array.new + invalid_item_ids << unfindable_item_id << unsellable_item.id << underpriced_item.id }
      let(:batch) { valid_items.map(&:id) + unclearancable_item_ids }

      before do
        @clearancing_status = clearancing_service.clearance_batch(batch)
      end

      it "detects all errors generated by invalid items" do
        expect(@clearancing_status.errors.count).to eq(unclearancable_item_ids.count)

        invalid_item_ids.each do |bad_id|
          expect(@clearancing_status.errors).to include("Item # #{bad_id} is not valid")
        end
        expect(@clearancing_status.errors).to include("Item # #{underpriced_item.id} does not meet the minimum clearance pricing criteria")
        expect(@clearancing_status.errors).to include("Item # #{unfindable_item_id} could not be found")
        expect(@clearancing_status.errors).to include("Item # #{unsellable_item.id} could not be clearanced")
      end

      it "includes all valid items in the batch" do
        expect(@clearancing_status.clearance_batch.items.pluck(:id)).to eq(valid_items.map(&:id))
      end
    end

    context "total failure" do
      let(:batch) { ["cat", 0, 3.3] }

      before do
        @clearancing_status = clearancing_service.clearance_batch(batch)
      end

      it "should indicate all items as having errors" do
        expect(@clearancing_status.errors.count).to eq(batch.count)
      end
      it "should not create a new ClearanceBatch" do
        expect(@clearancing_status.clearance_batch.new_record?).to be true
      end
    end
  end
end
